// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/magicalcosmos/goblogssr/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	ArticleWithPage() ArticleWithPageResolver
	Category() CategoryResolver
	CategoryWithPage() CategoryWithPageResolver
	Mutation() MutationResolver
	Query() QueryResolver
	User() UserResolver
	UserWithPage() UserWithPageResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Article struct {
		Brief      func(childComplexity int) int
		CategoryId func(childComplexity int) int
		Content    func(childComplexity int) int
		CreateAt   func(childComplexity int) int
		ID         func(childComplexity int) int
		Like       func(childComplexity int) int
		PublishAt  func(childComplexity int) int
		Published  func(childComplexity int) int
		Pv         func(childComplexity int) int
		Recommend  func(childComplexity int) int
		Review     func(childComplexity int) int
		Status     func(childComplexity int) int
		Tag        func(childComplexity int) int
		Title      func(childComplexity int) int
		UpdateAt   func(childComplexity int) int
		UserId     func(childComplexity int) int
	}

	ArticleWithPage struct {
		Articles func(childComplexity int) int
		Page     func(childComplexity int) int
	}

	Category struct {
		CreateAt func(childComplexity int) int
		ID       func(childComplexity int) int
		Name     func(childComplexity int) int
		ParentID func(childComplexity int) int
		Sort     func(childComplexity int) int
		Status   func(childComplexity int) int
		UpdateAt func(childComplexity int) int
	}

	CategoryWithPage struct {
		Categories func(childComplexity int) int
		Page       func(childComplexity int) int
	}

	Mutation struct {
		CreateArticle  func(childComplexity int, input model.NewArticle) int
		CreateCategory func(childComplexity int, input model.NewCategory) int
		CreateUser     func(childComplexity int, input model.NewUser) int
		DeleteArticle  func(childComplexity int, input model.NewArticle) int
		DeleteCategory func(childComplexity int, input model.NewCategory) int
		DeleteUser     func(childComplexity int, input model.NewUser) int
		Login          func(childComplexity int, input model.NewUser) int
		UpdateArticle  func(childComplexity int, input model.NewArticle) int
		UpdateCategory func(childComplexity int, input model.NewCategory) int
		UpdateUser     func(childComplexity int, input model.NewUser) int
	}

	Page struct {
		Content     func(childComplexity int) int
		CurrentPage func(childComplexity int) int
		OrderBy     func(childComplexity int) int
		PageSize    func(childComplexity int) int
		Total       func(childComplexity int) int
	}

	Query struct {
		ArticleList    func(childComplexity int, input model.Q) int
		CategoryList   func(childComplexity int, input model.Q) int
		GetArticleByID func(childComplexity int, input model.NewArticle) int
		UserList       func(childComplexity int, input model.Q) int
	}

	User struct {
		CreateAt func(childComplexity int) int
		Email    func(childComplexity int) int
		ID       func(childComplexity int) int
		Password func(childComplexity int) int
		Status   func(childComplexity int) int
		UpdateAt func(childComplexity int) int
		Username func(childComplexity int) int
	}

	UserWithPage struct {
		Page  func(childComplexity int) int
		Users func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Article.brief":
		if e.complexity.Article.Brief == nil {
			break
		}

		return e.complexity.Article.Brief(childComplexity), true

	case "Article.categoryId":
		if e.complexity.Article.CategoryId == nil {
			break
		}

		return e.complexity.Article.CategoryId(childComplexity), true

	case "Article.content":
		if e.complexity.Article.Content == nil {
			break
		}

		return e.complexity.Article.Content(childComplexity), true

	case "Article.createAt":
		if e.complexity.Article.CreateAt == nil {
			break
		}

		return e.complexity.Article.CreateAt(childComplexity), true

	case "Article.id":
		if e.complexity.Article.ID == nil {
			break
		}

		return e.complexity.Article.ID(childComplexity), true

	case "Article.like":
		if e.complexity.Article.Like == nil {
			break
		}

		return e.complexity.Article.Like(childComplexity), true

	case "Article.publishAt":
		if e.complexity.Article.PublishAt == nil {
			break
		}

		return e.complexity.Article.PublishAt(childComplexity), true

	case "Article.published":
		if e.complexity.Article.Published == nil {
			break
		}

		return e.complexity.Article.Published(childComplexity), true

	case "Article.pv":
		if e.complexity.Article.Pv == nil {
			break
		}

		return e.complexity.Article.Pv(childComplexity), true

	case "Article.recommend":
		if e.complexity.Article.Recommend == nil {
			break
		}

		return e.complexity.Article.Recommend(childComplexity), true

	case "Article.review":
		if e.complexity.Article.Review == nil {
			break
		}

		return e.complexity.Article.Review(childComplexity), true

	case "Article.status":
		if e.complexity.Article.Status == nil {
			break
		}

		return e.complexity.Article.Status(childComplexity), true

	case "Article.tag":
		if e.complexity.Article.Tag == nil {
			break
		}

		return e.complexity.Article.Tag(childComplexity), true

	case "Article.title":
		if e.complexity.Article.Title == nil {
			break
		}

		return e.complexity.Article.Title(childComplexity), true

	case "Article.updateAt":
		if e.complexity.Article.UpdateAt == nil {
			break
		}

		return e.complexity.Article.UpdateAt(childComplexity), true

	case "Article.userId":
		if e.complexity.Article.UserId == nil {
			break
		}

		return e.complexity.Article.UserId(childComplexity), true

	case "ArticleWithPage.articles":
		if e.complexity.ArticleWithPage.Articles == nil {
			break
		}

		return e.complexity.ArticleWithPage.Articles(childComplexity), true

	case "ArticleWithPage.page":
		if e.complexity.ArticleWithPage.Page == nil {
			break
		}

		return e.complexity.ArticleWithPage.Page(childComplexity), true

	case "Category.createAt":
		if e.complexity.Category.CreateAt == nil {
			break
		}

		return e.complexity.Category.CreateAt(childComplexity), true

	case "Category.id":
		if e.complexity.Category.ID == nil {
			break
		}

		return e.complexity.Category.ID(childComplexity), true

	case "Category.name":
		if e.complexity.Category.Name == nil {
			break
		}

		return e.complexity.Category.Name(childComplexity), true

	case "Category.parentId":
		if e.complexity.Category.ParentID == nil {
			break
		}

		return e.complexity.Category.ParentID(childComplexity), true

	case "Category.sort":
		if e.complexity.Category.Sort == nil {
			break
		}

		return e.complexity.Category.Sort(childComplexity), true

	case "Category.status":
		if e.complexity.Category.Status == nil {
			break
		}

		return e.complexity.Category.Status(childComplexity), true

	case "Category.updateAt":
		if e.complexity.Category.UpdateAt == nil {
			break
		}

		return e.complexity.Category.UpdateAt(childComplexity), true

	case "CategoryWithPage.categories":
		if e.complexity.CategoryWithPage.Categories == nil {
			break
		}

		return e.complexity.CategoryWithPage.Categories(childComplexity), true

	case "CategoryWithPage.page":
		if e.complexity.CategoryWithPage.Page == nil {
			break
		}

		return e.complexity.CategoryWithPage.Page(childComplexity), true

	case "Mutation.createArticle":
		if e.complexity.Mutation.CreateArticle == nil {
			break
		}

		args, err := ec.field_Mutation_createArticle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateArticle(childComplexity, args["input"].(model.NewArticle)), true

	case "Mutation.createCategory":
		if e.complexity.Mutation.CreateCategory == nil {
			break
		}

		args, err := ec.field_Mutation_createCategory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCategory(childComplexity, args["input"].(model.NewCategory)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(model.NewUser)), true

	case "Mutation.deleteArticle":
		if e.complexity.Mutation.DeleteArticle == nil {
			break
		}

		args, err := ec.field_Mutation_deleteArticle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteArticle(childComplexity, args["input"].(model.NewArticle)), true

	case "Mutation.deleteCategory":
		if e.complexity.Mutation.DeleteCategory == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCategory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCategory(childComplexity, args["input"].(model.NewCategory)), true

	case "Mutation.deleteUser":
		if e.complexity.Mutation.DeleteUser == nil {
			break
		}

		args, err := ec.field_Mutation_deleteUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteUser(childComplexity, args["input"].(model.NewUser)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["input"].(model.NewUser)), true

	case "Mutation.updateArticle":
		if e.complexity.Mutation.UpdateArticle == nil {
			break
		}

		args, err := ec.field_Mutation_updateArticle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateArticle(childComplexity, args["input"].(model.NewArticle)), true

	case "Mutation.updateCategory":
		if e.complexity.Mutation.UpdateCategory == nil {
			break
		}

		args, err := ec.field_Mutation_updateCategory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCategory(childComplexity, args["input"].(model.NewCategory)), true

	case "Mutation.updateUser":
		if e.complexity.Mutation.UpdateUser == nil {
			break
		}

		args, err := ec.field_Mutation_updateUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUser(childComplexity, args["input"].(model.NewUser)), true

	case "Page.content":
		if e.complexity.Page.Content == nil {
			break
		}

		return e.complexity.Page.Content(childComplexity), true

	case "Page.currentPage":
		if e.complexity.Page.CurrentPage == nil {
			break
		}

		return e.complexity.Page.CurrentPage(childComplexity), true

	case "Page.orderBy":
		if e.complexity.Page.OrderBy == nil {
			break
		}

		return e.complexity.Page.OrderBy(childComplexity), true

	case "Page.pageSize":
		if e.complexity.Page.PageSize == nil {
			break
		}

		return e.complexity.Page.PageSize(childComplexity), true

	case "Page.total":
		if e.complexity.Page.Total == nil {
			break
		}

		return e.complexity.Page.Total(childComplexity), true

	case "Query.articleList":
		if e.complexity.Query.ArticleList == nil {
			break
		}

		args, err := ec.field_Query_articleList_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.ArticleList(childComplexity, args["input"].(model.Q)), true

	case "Query.categoryList":
		if e.complexity.Query.CategoryList == nil {
			break
		}

		args, err := ec.field_Query_categoryList_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.CategoryList(childComplexity, args["input"].(model.Q)), true

	case "Query.getArticleById":
		if e.complexity.Query.GetArticleByID == nil {
			break
		}

		args, err := ec.field_Query_getArticleById_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.GetArticleByID(childComplexity, args["input"].(model.NewArticle)), true

	case "Query.userList":
		if e.complexity.Query.UserList == nil {
			break
		}

		args, err := ec.field_Query_userList_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.UserList(childComplexity, args["input"].(model.Q)), true

	case "User.createAt":
		if e.complexity.User.CreateAt == nil {
			break
		}

		return e.complexity.User.CreateAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.password":
		if e.complexity.User.Password == nil {
			break
		}

		return e.complexity.User.Password(childComplexity), true

	case "User.status":
		if e.complexity.User.Status == nil {
			break
		}

		return e.complexity.User.Status(childComplexity), true

	case "User.updateAt":
		if e.complexity.User.UpdateAt == nil {
			break
		}

		return e.complexity.User.UpdateAt(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	case "UserWithPage.page":
		if e.complexity.UserWithPage.Page == nil {
			break
		}

		return e.complexity.UserWithPage.Page(childComplexity), true

	case "UserWithPage.users":
		if e.complexity.UserWithPage.Users == nil {
			break
		}

		return e.complexity.UserWithPage.Users(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputNewArticle,
		ec.unmarshalInputNewCategory,
		ec.unmarshalInputNewUser,
		ec.unmarshalInputQ,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/article-schema.graphqls", Input: `
type Article {
  id: Int!
  userId: Int!
  categoryId: Int!
  title: String!
  brief: String!
  content: String!
  published: Int!
  tag: String!
  pv: Int!
  review: Int!
  recommend: Int!
  like: Int!
  status: Int!
  createAt: Time!
  updateAt: Time!
  publishAt: Time!
}
type ArticleWithPage {
  articles: [Article!]!
  page: Page!
}

input NewArticle {
  id: Int
  userId: Int
  categoryId: Int
  title: String
  brief: String
  content: String
  published: Int
  publishAt: Time
  tag: String
  pv: Int
  review: Int
  recommend: Int
  like: Int
  status: Int
}

extend type Query {
  """ 获取文章列表 """
  articleList(input: Q!): ArticleWithPage!

  """ 根据获取文章列表 """
  getArticleById(input: NewArticle!): Article!
}

extend type Mutation {

  """ 创建文章 """
  createArticle(input: NewArticle!): Article!

  """ 更新文章 """
  updateArticle(input: NewArticle!): Article!

  """ 删除文章 """
  deleteArticle(input: NewArticle!): String!
}`, BuiltIn: false},
	{Name: "../schema/category-schema.graphqls", Input: `type Category {
  id: Int!
  name: String!
  parentId: String!
  sort: Int!
  status: Int!
  createAt: Time!
  updateAt: Time!
}

type CategoryWithPage {
  categories: [Category!]!
  page: Page!
}


input NewCategory {
  id: Int
  name: String
  parentId: Int
  sort: Int
}

extend type Query {
  """ 获取分类目录列表 """
  categoryList(input: Q!): CategoryWithPage!
}

extend type Mutation {

  """ 创建分类 """
  createCategory(input: NewCategory!): Category!

  """ 更新分类 """
  updateCategory(input: NewCategory!): Category!

  """ 删除分类 """
  deleteCategory(input: NewCategory!): String!
}`, BuiltIn: false},
	{Name: "../schema/schema.graphqls", Input: `""" 文件上传 """
scalar Upload
scalar Any
scalar Time
scalar Map

input Q {
	content:     String
	pageSize:    Int
	total:       Int 
	currentPage: Int 
	orderBy:     String
}

type Page {
	content:     String
	pageSize:    Int
	total:       Int 
	currentPage: Int 
	orderBy:     String
}
`, BuiltIn: false},
	{Name: "../schema/user-schema.graphqls", Input: `type User {
  id: Int!
  username: String!
  password: String!
  email: String!
  status: Int!
  createAt: Time!
  updateAt: Time!
}

type UserWithPage {
  users: [User!]!
  page: Page!
}

input NewUser {
  id: Int
  username: String
  password: String
  email: String
}


extend type Query {

  """ 获取用户列表 """
  userList(input: Q!): UserWithPage!
}

extend type Mutation {

  """ 登录 """
  login(input: NewUser!): Boolean!

  """ 创建用户 """
  createUser(input: NewUser!): User!

  """ 更新用户 """
  updateUser(input: NewUser!): User!

  """ 删除用户 """
  deleteUser(input: NewUser!): String!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
