// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/magicalcosmos/goblogssr/graph/model"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Article() ArticleResolver
	Category() CategoryResolver
	Mutation() MutationResolver
	Query() QueryResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Article struct {
		AuthorID  func(childComplexity int) int
		Brief     func(childComplexity int) int
		Content   func(childComplexity int) int
		CreateAt  func(childComplexity int) int
		ID        func(childComplexity int) int
		Like      func(childComplexity int) int
		ParentID  func(childComplexity int) int
		Published func(childComplexity int) int
		Pv        func(childComplexity int) int
		Recommend func(childComplexity int) int
		Review    func(childComplexity int) int
		Status    func(childComplexity int) int
		Tag       func(childComplexity int) int
		Title     func(childComplexity int) int
		UpdateAt  func(childComplexity int) int
	}

	Category struct {
		CreateAt func(childComplexity int) int
		ID       func(childComplexity int) int
		Name     func(childComplexity int) int
		ParentId func(childComplexity int) int
		Sort     func(childComplexity int) int
		Status   func(childComplexity int) int
		UpdateAt func(childComplexity int) int
	}

	Mutation struct {
		CreateArticle  func(childComplexity int, input model.NewArticle) int
		CreateCategory func(childComplexity int, input model.NewCategory) int
		CreateUser     func(childComplexity int, input model.NewUser) int
		Login          func(childComplexity int, input model.NewUser) int
		UpdateArticle  func(childComplexity int, input model.NewArticle) int
		UpdateCategory func(childComplexity int, input model.NewCategory) int
	}

	Query struct {
		Articles   func(childComplexity int) int
		Categories func(childComplexity int) int
		Users      func(childComplexity int) int
	}

	User struct {
		CreateAt func(childComplexity int) int
		Email    func(childComplexity int) int
		ID       func(childComplexity int) int
		Password func(childComplexity int) int
		Status   func(childComplexity int) int
		UpdateAt func(childComplexity int) int
		Username func(childComplexity int) int
	}
}

type executableSchema struct {
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Article.authorId":
		if e.complexity.Article.AuthorID == nil {
			break
		}

		return e.complexity.Article.AuthorID(childComplexity), true

	case "Article.brief":
		if e.complexity.Article.Brief == nil {
			break
		}

		return e.complexity.Article.Brief(childComplexity), true

	case "Article.content":
		if e.complexity.Article.Content == nil {
			break
		}

		return e.complexity.Article.Content(childComplexity), true

	case "Article.createAt":
		if e.complexity.Article.CreateAt == nil {
			break
		}

		return e.complexity.Article.CreateAt(childComplexity), true

	case "Article.id":
		if e.complexity.Article.ID == nil {
			break
		}

		return e.complexity.Article.ID(childComplexity), true

	case "Article.like":
		if e.complexity.Article.Like == nil {
			break
		}

		return e.complexity.Article.Like(childComplexity), true

	case "Article.parentId":
		if e.complexity.Article.ParentID == nil {
			break
		}

		return e.complexity.Article.ParentID(childComplexity), true

	case "Article.published":
		if e.complexity.Article.Published == nil {
			break
		}

		return e.complexity.Article.Published(childComplexity), true

	case "Article.pv":
		if e.complexity.Article.Pv == nil {
			break
		}

		return e.complexity.Article.Pv(childComplexity), true

	case "Article.recommend":
		if e.complexity.Article.Recommend == nil {
			break
		}

		return e.complexity.Article.Recommend(childComplexity), true

	case "Article.review":
		if e.complexity.Article.Review == nil {
			break
		}

		return e.complexity.Article.Review(childComplexity), true

	case "Article.status":
		if e.complexity.Article.Status == nil {
			break
		}

		return e.complexity.Article.Status(childComplexity), true

	case "Article.tag":
		if e.complexity.Article.Tag == nil {
			break
		}

		return e.complexity.Article.Tag(childComplexity), true

	case "Article.title":
		if e.complexity.Article.Title == nil {
			break
		}

		return e.complexity.Article.Title(childComplexity), true

	case "Article.updateAt":
		if e.complexity.Article.UpdateAt == nil {
			break
		}

		return e.complexity.Article.UpdateAt(childComplexity), true

	case "Category.createAt":
		if e.complexity.Category.CreateAt == nil {
			break
		}

		return e.complexity.Category.CreateAt(childComplexity), true

	case "Category.id":
		if e.complexity.Category.ID == nil {
			break
		}

		return e.complexity.Category.ID(childComplexity), true

	case "Category.name":
		if e.complexity.Category.Name == nil {
			break
		}

		return e.complexity.Category.Name(childComplexity), true

	case "Category.parentId":
		if e.complexity.Category.ParentId == nil {
			break
		}

		return e.complexity.Category.ParentId(childComplexity), true

	case "Category.sort":
		if e.complexity.Category.Sort == nil {
			break
		}

		return e.complexity.Category.Sort(childComplexity), true

	case "Category.status":
		if e.complexity.Category.Status == nil {
			break
		}

		return e.complexity.Category.Status(childComplexity), true

	case "Category.updateAt":
		if e.complexity.Category.UpdateAt == nil {
			break
		}

		return e.complexity.Category.UpdateAt(childComplexity), true

	case "Mutation.createArticle":
		if e.complexity.Mutation.CreateArticle == nil {
			break
		}

		args, err := ec.field_Mutation_createArticle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateArticle(childComplexity, args["input"].(model.NewArticle)), true

	case "Mutation.createCategory":
		if e.complexity.Mutation.CreateCategory == nil {
			break
		}

		args, err := ec.field_Mutation_createCategory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCategory(childComplexity, args["input"].(model.NewCategory)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(model.NewUser)), true

	case "Mutation.login":
		if e.complexity.Mutation.Login == nil {
			break
		}

		args, err := ec.field_Mutation_login_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.Login(childComplexity, args["input"].(model.NewUser)), true

	case "Mutation.updateArticle":
		if e.complexity.Mutation.UpdateArticle == nil {
			break
		}

		args, err := ec.field_Mutation_updateArticle_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateArticle(childComplexity, args["input"].(model.NewArticle)), true

	case "Mutation.updateCategory":
		if e.complexity.Mutation.UpdateCategory == nil {
			break
		}

		args, err := ec.field_Mutation_updateCategory_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCategory(childComplexity, args["input"].(model.NewCategory)), true

	case "Query.articles":
		if e.complexity.Query.Articles == nil {
			break
		}

		return e.complexity.Query.Articles(childComplexity), true

	case "Query.categories":
		if e.complexity.Query.Categories == nil {
			break
		}

		return e.complexity.Query.Categories(childComplexity), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "User.createAt":
		if e.complexity.User.CreateAt == nil {
			break
		}

		return e.complexity.User.CreateAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.password":
		if e.complexity.User.Password == nil {
			break
		}

		return e.complexity.User.Password(childComplexity), true

	case "User.status":
		if e.complexity.User.Status == nil {
			break
		}

		return e.complexity.User.Status(childComplexity), true

	case "User.updateAt":
		if e.complexity.User.UpdateAt == nil {
			break
		}

		return e.complexity.User.UpdateAt(childComplexity), true

	case "User.username":
		if e.complexity.User.Username == nil {
			break
		}

		return e.complexity.User.Username(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	rc := graphql.GetOperationContext(ctx)
	ec := executionContext{rc, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputNewArticle,
		ec.unmarshalInputNewCategory,
		ec.unmarshalInputNewUser,
	)
	first := true

	switch rc.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, rc.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, rc.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(parsedSchema), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(parsedSchema, parsedSchema.Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/article-schema.graphqls", Input: `
type Article {
  id: ID!
  authorId: Int!
  parentId: Int!
  title: String!
  brief: String!
  content: String!
  published: Int!
  tag: String!
  pv: Int!
  review: Int!
  recommend: Int!
  like: Int!
  status: Int!
  createAt: Time!
  updateAt: Time!
}

input NewArticle {
  id: ID
  authorId: Int
  parentId: Int
  title: String
  brief: String
  content: String
  published: Int
  tag: String
  pv: Int
  review: Int
  recommend: Int
  like: Int
  status: Int
}

extend type Query {
  """ 获取文章列表 """
  articles: [Article!]!

}

extend type Mutation {

  """ 创建文章 """
  createArticle(input: NewArticle!): Article!

  """ 更新文章 """
  updateArticle(input: NewArticle!): Article!
}`, BuiltIn: false},
	{Name: "../schema/category-schema.graphqls", Input: `type Category {
  id: ID!
  name: String!
  parentId: String!
  sort: Int!
  status: Int!
  createAt: Time!
  updateAt: Time!
}

input NewCategory {
  id: ID
  name: String
  parentId: Int
  sort: Int
}

extend type Query {
  """ 获取分类目录列表 """
  categories: [Category!]!

}

extend type Mutation {

  """ 创建分类 """
  createCategory(input: NewCategory!): Category!

  """ 更新分类 """
  updateCategory(input: NewCategory!): Category!
}`, BuiltIn: false},
	{Name: "../schema/schema.graphqls", Input: `""" 文件上传 """
scalar Upload
scalar Any
scalar Time
scalar Map`, BuiltIn: false},
	{Name: "../schema/user-schema.graphqls", Input: `type User {
  id: ID!
  username: String!
  password: String!
  email: String!
  status: Int!
  createAt: Time!
  updateAt: Time!
}

input NewUser {
  username: String!
  password: String!
}

extend type Query {

  """ 获取用户列表 """
  users: [User!]!
}

extend type Mutation {

  """ 登录 """
  login(input: NewUser!): Boolean!

  """ 创建用户 """
  createUser(input: NewUser!): User!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
